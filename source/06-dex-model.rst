06. DEX model
=============

There is a general model of a DEX (derived from the TLA+ spec we mentioned before) which sits at the conceptual center
of Dexter design. Only one part of this model - the executor - is pluggable, so that comparative simulation of various
executors ca nbe achieved.

In this chapter we describe this common base model, while the next chapter is devoted to the various executors
pre-installed in the current version of Dexter.

This chapter covers perspective (4) according to the list of perspectives explained in chapter 5.

This UML diagram covers the whole model:

.. image:: pictures/06/dex-uml-model.png
    :width: 100%
    :align: center

Coins and tokens
----------------

We use the term **coin** meaning "type of cryptocurrency". For example, in our lingo, BTC and ETH are coins. On the
other hand, we use the term **token** when we talk about amounts of coins. In practice: when I sell 1.305
bitcoins, we say that the the coin of that transaction is "bitcoin" and the number of tokens transferred is 1.305.

Coins are represented with ``Coin`` type, while token amounts are represented with ``FPNumber`` type.

We frequently need to talk about pairs of coins. When ``AAA`` and ``BBB`` are some coins, we want to be able to form
the pairs ``(AAA,BBB)`` and ``(BBB,AAA)``. This concept is represented with ``CoinPair`` type.

We also sometimes need 2-element coin sets. This is different than a coin pair, because a pair is ordered, while a set is
not. However, to keep things simpler, we represent a 2-element coin set as a **normalized coin pair**. This normalization
works as follows: because every coin has an id (hash), we consider a CoinPair to be **normalized** if coins in this
pair are ordered along their hashes.

Coins collection is automatically generated on simulation start.

**Example**

With number of coins configured to 7, at the beginning of the simulation the following information will show up in the
console:

.. code::

   coins in use:
     code=AAA id=ee93-992a-dbdd-6168 description=Sample coin AAA
     code=BBB id=9853-0e3b-6c5e-fd60 description=Sample coin BBB
     code=CCC id=aea4-0d22-8e88-7e5b description=Sample coin CCC
     code=DDD id=ba32-7373-3682-7484 description=Sample coin DDD
     code=EEE id=e999-5a44-0ea6-4d46 description=Sample coin EEE
     code=FFF id=1531-f159-e87b-6776 description=Sample coin FFF
     code=GGG id=a8f4-8174-5e0a-3c25 description=Sample coin GGG


   >>> coins in use:
     code=AAA id=ee93-992a-dbdd-6168 description=Sample coin AAA
     code=BBB id=9853-0e3b-6c5e-fd60 description=Sample coin BBB
     code=CCC id=aea4-0d22-8e88-7e5b description=Sample coin CCC
     code=DDD id=ba32-7373-3682-7484 description=Sample coin DDD
     code=EEE id=e999-5a44-0ea6-4d46 description=Sample coin EEE
     code=FFF id=1531-f159-e87b-6776 description=Sample coin FFF
     code=GGG id=a8f4-8174-5e0a-3c25 description=Sample coin GGG

sf s fs sd fsd fsdf

 |   coins in use:
 |     code=AAA id=ee93-992a-dbdd-6168 description=Sample coin AAA
 |     code=BBB id=9853-0e3b-6c5e-fd60 description=Sample coin BBB
 |     code=CCC id=aea4-0d22-8e88-7e5b description=Sample coin CCC
 |     code=DDD id=ba32-7373-3682-7484 description=Sample coin DDD
 |     code=EEE id=e999-5a44-0ea6-4d46 description=Sample coin EEE
 |     code=FFF id=1531-f159-e87b-6776 description=Sample coin FFF
 |     code=GGG id=a8f4-8174-5e0a-3c25 description=Sample coin GGG

These are automatically generated coins. For coins AAA and BBB, two coin pairs are possible: ``CoinPair(AAA,BBB)`` and
``CoinPair(BBB,AAA)``. Now let us look at the hashes. A hash is printed using hex encoding of corresponding byte array
and the comparison of hashes is lexicographic-per-byte. First byte of coin AAA identifier is ``ee`` in hex, which is
number 238. First byte of coin BBB identifier is ``98`` in hex, which is number 152. Hence, BBB has smaller hash than
AAA so we can conclude that ``CoinPair(BBB,AAA)`` is the normalized and ``CoinPair(AAA, BBB)`` is normalized.

DEX core
--------

``DexCore`` keeps all the information needed to process transactions generated by traders:

  - coins
  - reserve state
  - all trader accounts
  - markets

``DexCore`` stands as a facade for decentralized exchange operations (see :ref:`dex-operations-spec`).

On top of this, ``DexCore`` calculates exchange statistics. We describe all simulation statistics in chapter 12.

We also have ``DexFacade``, which plays the role of a more "high level" API to the DEX, while ``DexCore`` offers API
structure closer to the TLA+ spec.

Trader accounts
---------------

Trader account is just the same as blockchain account. DEX becomes aware of a trader account while executing the first
**deposit** operation for this account.

An account stores the following information:

 - current balance of tokens (per each coin)
 - current free balance of tokens (per each coin) - this is related to funds locking, see below
 - current balance of liquidity tokens (per market)
 - opened positions

Reserve
-------

Reserve is the way we represent total tokens supply (per coin):

 - transferring tokens from reserve to trader account corresponds to "minting" tokens
 - transferring tokens from trader account to reserve corresponds to "burning" tokens

Reserve is represented as a battery-of-counters, indexed by coin.

The following DexFacade operations deal with reserve:

.. code:: scala

   class DexFacade {

     //Take a number of tokens (of specific coin) from the reserve and place it into an exchange account.
     def deposit(accountAddress: AccountAddress, accountName: String, amount: FPNumber, coin: Coin): Unit

     //Take a number of tokens (of specific coin) from specified trader account and return it to the reserve.
     def withdraw(accountAddress: AccountAddress, amount: FPNumber, coin: Coin): Unit

   }.

Markets
-------

DEX contains the collection of markets. For every normalized pair of coins we generate one market. This follows the
tradition of Forex: a market AAA/BBB is where coin AAA can be traded for BBB and coin BBB can be traded for AAA.

We also borrow from Forex another naming convention: base/quote. Base is the coin we think of as being the "asset" and
quote is the coin we think of as being the "money". The selection of base is arbitrary - we just again use the
normalization of coin pairs here and in a normalized coin pair ``CoinPair(AAA,BBB)``, left-side coin (AAA in this example)
is base, while right-side coin (BBB in this example) is quote.

Base-quote convention is basically a way to pick some orientation of the market (which is otherwise fully symmetric),
hence talking about buyers, sellers and prices becomes unambiguous without further explanation of which coin we are
selling. With base/quote setup in place, whoever is selling the base coin is the seller, and whoever is buying the base
coin is the buyer. The price is then the amount of quote tokens to be paid for 1 base token.

A market maintains 4 ordered collections of orders:

  - limit orders (buyers collection)
  - limit orders (sellers collection)
  - stop orders (buyers collection)
  - stop orders (sellers collection)

Caution: stop orders are considered "experimental" feature and are not fully covered by this version of Dexter manual.

A market also contains a liquidity pool (also called "automated market maker" or AMM), which is a "locked" amount
of base tokens and quote tokens.

Liquidity pools
---------------

A separate liquidity pool is attached to every market. Liquidity pool is composed of 2 elements:

  - two variables - ``ammBase`` and ``ammQuote`` - keeping track of base coin and quote coin amounts in the pool
  - a collection of "drops"

Liquidity pool is the way we establish the concept of "current price" on the market: it is just the value
``ammQuote / ammBase``.

The way DEX is executing orders is fundamentally based on liquidity pools. Instead of matching sell and buy orders
(as happens on Forex), the DEX executes trading against the liquidity pool attached to the relevant market. How exactly
this execution works depends on a specific executor in use (see next chapter).

Any trader can become a liquidity provider. Becoming a liquidity provider happens one of these operations:

.. code:: scala

   class DexFacade {

     //Initialize liquidity pool.
     def initAMM(account: AccountAddress, aCoin: Coin, bCoin: Coin, aCoinAmount: FPNumber, bCoinAmount: FPNumber): Boolean

     //Add liquidity to an already initialized pool.
     //Only one coin and its amount is provided as argument, the other side is automatically calculated
     def addLiquidity(accountAddress: AccountAddress, marketId: CoinPair, amountCoin: Coin, amount: FPNumber): Boolean

   }

Drops collection is the way DEX tracks participation of traders in given liquidity pool. Participation tracking is based
on a fictional coin (liquidity coin), and every drops is a collection keeping the balance of liquidity coin for every
trader.

``InitAMM`` just allocates fixed amount of liquidity coins (100.0) as drops entry for the issuing trader.

``AddLiquidity`` ensures that the amounts of base and quote coin transferred from trader account will not change
the current price. If :math:`ammBase` and :math:`ammQuote` are the initial balances of the AMM, and the trader adds
liquidity by transferring :math:`x` tokens of base coin and `y` tokens of quote coin, the DEX ensures that the following
condition holds:

.. math::

  \frac{ammBase}{ammQuote}=\frac{ammBase+x}{ammQuote+y}

Let:

  - :math:`td` denote the total amount of liquidity tokens minted for the market
  - :math:`d` denote the amount of liquidity tokens DEX will mint in effect of ``AddLiquidity``

Then ``AddLiquidity`` follows this equation:

.. math::

  \frac{x}{ammBase}=\frac{d}{td}


Orders
------

sfsd

Funds locking/unlocking
-----------------------

fsdf

Market orientation
------------------

sdf

Liquidity providers
-------------------

fsfs

Representation of an order book
-------------------------------
sfsd


Data stored in a trader account
-------------------------------
sfsd

.. _dex-operations-spec:

DEX operations
--------------

Execution of orders
-------------------







